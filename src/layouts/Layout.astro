---
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import SEO from "../components/SEO.astro";
import "../styles/global.css";
import "../styles/tailwind.css"; // Content controlled by init-recipe based on features.tailwind
import { ClientRouter } from "astro:transitions";
import { siteConfig } from "../config/site";

interface Props {
  /** Page title */
  title: string;
  /** Page description for meta and social sharing */
  description?: string;
  /** Open Graph image URL (absolute URL recommended) */
  image?: string;
  /** Page type for Open Graph (default: website) */
  type?: "website" | "article" | "product";
  /** Canonical URL override */
  canonical?: string;
  /** Disable search engine indexing */
  noindex?: boolean;
}

const { title, description, image, type, canonical, noindex } = Astro.props;

// Feature flags from config
const { smoothScrolling, customScrollbar, viewTransitions, scrollbarThumbStyle, tailwind } =
  siteConfig.features;

// Dark theme flag for scrollbar and sub-nav styling
const isDark = siteConfig.isDark || false;

// Scrollbar thumb style - 'auto' (thin, expands on hover) or 'full' (always full width)
const thumbStyle = scrollbarThumbStyle || 'auto';
---

<!doctype html>
<html lang="en" data-theme={isDark ? "dark" : undefined}>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <SEO
      title={title}
      description={description}
      image={image}
      type={type}
      canonical={canonical}
      noindex={noindex}
    />
    {viewTransitions && <ClientRouter />}
    <link
      rel="preload"
      href="/fonts/fraunces-latin.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <link
      rel="preload"
      href="/fonts/outfit-latin.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
        <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=DM+Serif+Display&display=swap" rel="stylesheet">
<style>
      /* Self-hosted fonts */
      @font-face {
        font-family: "Fraunces";
        font-style: normal;
        font-weight: 400 700;
        font-display: swap;
        src: url("/fonts/fraunces-latin.woff2") format("woff2");
        unicode-range:
          U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC,
          U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193,
          U+2212, U+2215, U+FEFF, U+FFFD;
      }
      @font-face {
        font-family: "Outfit";
        font-style: normal;
        font-weight: 300 700;
        font-display: swap;
        src: url("/fonts/outfit-latin.woff2") format("woff2");
        unicode-range:
          U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC,
          U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193,
          U+2212, U+2215, U+FEFF, U+FFFD;
      }
    </style>
    {
      siteConfig.logo.src && siteConfig.logo.src.trim() !== "" && (
        <link rel="preload" href={siteConfig.logo.src} as="image" />
      )
    }
  </head>
  <body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    <Header />
    <main id="main-content">
      <slot />
    </main>
    <Footer />

    {/* Custom Scrollbar Structure - conditionally rendered */}
    {
      customScrollbar && (
        <div class="custom-scrollbar" data-thumb-style={thumbStyle}>
          <div class="scroll-arrow scroll-arrow-up" aria-hidden="true" />
          <div class="scroll-track">
            <div class="custom-thumb" />
          </div>
          <div class="scroll-arrow scroll-arrow-down" aria-hidden="true"></div>
        </div>
      )
    }

    <script define:vars={{ smoothScrolling, customScrollbar }}>
      // Store feature flags globally for the initialization script
      window.__featureFlags = {
        smoothScrolling,
        customScrollbar,
      };

      // Premium support reminder - shown once per session in dev console
      if (typeof sessionStorage !== 'undefined' && !sessionStorage.getItem('mostra-support-shown')) {
        // Check if this is dev mode (localhost or dev environment)
        const isDev = window.location.hostname === 'localhost' ||
                      window.location.hostname === '127.0.0.1' ||
                      window.location.port !== '';

        if (isDev) {
          console.log('%câœ¨ Enjoying Mostra?', 'font-size: 14px; font-weight: bold; color: #6366f1;');
          console.log('%cConsider supporting development:', 'color: #64748b;');
          console.log('%c  â˜• https://ko-fi.com/sofondo', 'color: #3b82f6;');
          console.log('%c  ðŸ’œ https://github.com/sponsors/sofondo', 'color: #8b5cf6;');
          sessionStorage.setItem('mostra-support-shown', 'true');
        }
      }
    </script>

    <script>
      import Lenis from "@studio-freight/lenis";

      function initSmoothScrolling() {
        const flags = (window as any).__featureFlags || {};
        if (!flags.smoothScrolling && !flags.customScrollbar) return;

        // Custom Scrollbar Logic
        const scrollbar = document.querySelector(
          ".custom-scrollbar",
        ) as HTMLElement;
        const track = document.querySelector(".scroll-track") as HTMLElement;
        const thumb = document.querySelector(".custom-thumb") as HTMLElement;
        const arrowUp = document.querySelector(
          ".scroll-arrow-up",
        ) as HTMLElement;
        const arrowDown = document.querySelector(
          ".scroll-arrow-down",
        ) as HTMLElement;

        if (
          !flags.customScrollbar ||
          !scrollbar ||
          !track ||
          !thumb ||
          !arrowUp ||
          !arrowDown
        ) {
          // If no custom scrollbar but smooth scrolling is enabled, still init Lenis
          if (flags.smoothScrolling) {
            const lenis = new Lenis({
              duration: 1.2,
              easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
              orientation: "vertical",
              gestureOrientation: "vertical",
              smoothWheel: true,
              wheelMultiplier: 1,
              touchMultiplier: 2,
            });

            window.addEventListener("mobile-menu-toggle", ((e: CustomEvent) => {
              const isOpen = e.detail.isOpen;
              if (isOpen) {
                lenis?.stop();
                document.documentElement.style.overflow = "hidden";
                document.body.style.overflow = "hidden";
                document.body.classList.add("mobile-menu-open");
              } else {
                lenis?.start();
                document.documentElement.style.overflow = "";
                document.body.style.overflow = "";
                document.body.classList.remove("mobile-menu-open");
              }
            }) as EventListener);

            function raf(time: number) {
              lenis.raf(time);
              requestAnimationFrame(raf);
            }
            requestAnimationFrame(raf);
          }
          return;
        }

        // Initialize Lenis
        const lenis = new Lenis({
          duration: 1.2,
          easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
          orientation: "vertical",
          gestureOrientation: "vertical",
          smoothWheel: true,
          wheelMultiplier: 1,
          touchMultiplier: 2,
        });

        // Listen for mobile menu toggle events
        window.addEventListener("mobile-menu-toggle", ((e: CustomEvent) => {
          const isOpen = e.detail.isOpen;
          if (isOpen) {
            lenis?.stop();
            document.documentElement.style.overflow = "hidden";
            document.body.style.overflow = "hidden";
            document.body.classList.add("mobile-menu-open");
          } else {
            lenis?.start();
            document.documentElement.style.overflow = "";
            document.body.style.overflow = "";
            document.body.classList.remove("mobile-menu-open");
          }
        }) as EventListener);

        let isDragging = false;
        let startY = 0;
        let startScroll = 0;
        let forcedThumbPosition: number | null = null;
        let targetScrollPosition: number | null = null;
        let lastScrollTime = 0;
        let velocity = 0;
        let isCatchingUp = false;

        // Arrow Physics State
        let arrowDirection = 0;
        let arrowVelocity = 0;
        const ARROW_ACCEL = 1.5;
        const ARROW_MAX_SPEED = 25;
        const ARROW_FRICTION = 0.92;

        function startArrowScroll(direction: "up" | "down") {
          if (isDragging) {
            isDragging = false;
            thumb.classList.remove("dragging");
            document.body.style.userSelect = "";
          }
          forcedThumbPosition = null;
          targetScrollPosition = null;
          arrowDirection = direction === "up" ? -1 : 1;
        }

        function stopArrowScroll() {
          arrowDirection = 0;
        }

        const handleArrowUp = () => startArrowScroll("up");
        const handleArrowDown = () => startArrowScroll("down");

        arrowUp.addEventListener("mousedown", handleArrowUp);
        arrowDown.addEventListener("mousedown", handleArrowDown);

        window.addEventListener("mouseup", stopArrowScroll);
        [arrowUp, arrowDown].forEach((arrow) => {
          arrow.addEventListener("mouseleave", stopArrowScroll);
        });

        // Show scrollbar on scroll
        let scrollTimeout: ReturnType<typeof setTimeout>;
        const handleScroll = () => {
          scrollbar.classList.add("scrolling");
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(() => {
            scrollbar.classList.remove("scrolling");
          }, 1000);
        };
        window.addEventListener("scroll", handleScroll);

        function updateScrollbar() {
          if (!lenis) return;

          const scrollHeight = document.documentElement.scrollHeight;
          const clientHeight = window.innerHeight;

          if (scrollHeight <= clientHeight) {
            scrollbar.style.opacity = "0";
            scrollbar.style.pointerEvents = "none";
            return;
          }
          scrollbar.style.opacity = "1";
          scrollbar.style.pointerEvents = "auto";

          const trackHeight = track.clientHeight;
          const scrollRatio = clientHeight / scrollHeight;
          const thumbHeight = Math.max(40, trackHeight * scrollRatio);
          thumb.style.height = `${thumbHeight}px`;

          const maxScroll = scrollHeight - clientHeight;
          const maxThumbTop = trackHeight - thumbHeight;

          // Update thumb position based on scroll
          if (!isDragging) {
            let scrollPos = lenis.scroll;

            if (isCatchingUp && targetScrollPosition !== null) {
              if (Math.abs(lenis.scroll - targetScrollPosition) < 2) {
                isCatchingUp = false;
              } else {
                scrollPos = targetScrollPosition;
              }
            }

            // Normal scroll - update thumb position to match scroll
            const progress = scrollPos / maxScroll;
            const thumbTop = progress * maxThumbTop;
            thumb.style.transform = `translateY(${thumbTop}px)`;
          }
        }

        // Set up event listeners ONCE
        lenis.on("scroll", updateScrollbar);
        window.addEventListener("resize", updateScrollbar);

        // Initial update
        updateScrollbar();

        // Mouse event handlers for thumb dragging
        const handleThumbMouseDown = (e: MouseEvent) => {
          if (!lenis) return;
          isDragging = true;
          isCatchingUp = false;
          forcedThumbPosition = null;
          targetScrollPosition = null;
          startY = e.clientY;
          startScroll = lenis.scroll;
          thumb.classList.add("dragging");
          document.body.style.userSelect = "none";
        };
        thumb.addEventListener("mousedown", handleThumbMouseDown);

        const handleMouseMove = (e: MouseEvent) => {
          if (!isDragging || !lenis) return;
          e.preventDefault();

          const currentTime = Date.now();
          const deltaY = e.clientY - startY;
          const scrollHeight = document.documentElement.scrollHeight;
          const clientHeight = window.innerHeight;
          const trackHeight = track.clientHeight;
          const thumbHeight = parseFloat(thumb.style.height);
          const maxThumbTop = trackHeight - thumbHeight;
          const maxScroll = scrollHeight - clientHeight;

          const scrollRatio = maxScroll / maxThumbTop;
          const targetScroll = Math.max(
            0,
            Math.min(startScroll + deltaY * scrollRatio, maxScroll),
          );

          // Calculate velocity
          const dt = currentTime - lastScrollTime;
          if (dt > 0) {
            velocity = (targetScroll - lenis.scroll) / dt;
          }
          lastScrollTime = currentTime;

          // Calculate and set thumb position immediately during drag
          const progress = targetScroll / maxScroll;
          const thumbTop = progress * maxThumbTop;

          if (!isNaN(thumbTop)) {
            thumb.style.transform = `translateY(${thumbTop}px)`;
            // Store this position for after release
            forcedThumbPosition = thumbTop;
            targetScrollPosition = targetScroll;
          }

          // Initiate smooth scroll with inertia (immediate: false)
          lenis.scrollTo(targetScroll, { immediate: false });
        };
        window.addEventListener("mousemove", handleMouseMove);

        const handleMouseUp = () => {
          if (isDragging) {
            isDragging = false;
            isCatchingUp = true;
            thumb.classList.remove("dragging");
            document.body.style.userSelect = "";
          }
        };
        window.addEventListener("mouseup", handleMouseUp);

        function raf(time: number) {
          if (!lenis) return;
          try {
            lenis.raf(time);

            // Handle Arrow Physics
            if (arrowDirection !== 0) {
              arrowVelocity += arrowDirection * ARROW_ACCEL;
              if (arrowVelocity > ARROW_MAX_SPEED)
                arrowVelocity = ARROW_MAX_SPEED;
              if (arrowVelocity < -ARROW_MAX_SPEED)
                arrowVelocity = -ARROW_MAX_SPEED;
            } else {
              arrowVelocity *= ARROW_FRICTION;
              if (Math.abs(arrowVelocity) < 0.1) arrowVelocity = 0;
            }

            if (Math.abs(arrowVelocity) > 0.1) {
              lenis.scrollTo(lenis.scroll + arrowVelocity, { immediate: true });
              updateScrollbar();
            }
          } catch (e) {
            // Silently handle scroll errors
          }
          requestAnimationFrame(raf);
        }

        requestAnimationFrame(raf);

        // Context-Aware Scrollbar: Independent theme detection for thumb and arrows
        const sections = document.querySelectorAll("[data-bg-theme]");

        function getThemeAtPosition(pageY: number): string | null {
          if (sections.length === 0) return null;

          for (let i = 0; i < sections.length; i++) {
            const section = sections[i];
            const rect = section.getBoundingClientRect();
            const sectionTop = window.scrollY + rect.top;
            const sectionBottom = sectionTop + rect.height;

            if (pageY >= sectionTop && pageY < sectionBottom) {
              return section.getAttribute("data-bg-theme");
            }
          }

          // If past all sections, use last section's theme
          const lastSection = sections[sections.length - 1];
          const lastRect = lastSection.getBoundingClientRect();
          const lastBottom = window.scrollY + lastRect.top + lastRect.height;
          if (pageY >= lastBottom) {
            return lastSection.getAttribute("data-bg-theme");
          }

          return null;
        }

        function getThemeAtScreenY(
          screenY: number,
          checkHeader: boolean = false,
        ): string | null {
          // Check if the header is covering this position (header is fixed/sticky at top)
          if (checkHeader) {
            const header = document.querySelector("header");
            if (header) {
              const headerRect = header.getBoundingClientRect();
              if (screenY >= headerRect.top && screenY < headerRect.bottom) {
                // Header is visible at this Y position
                // Check if header has a data-bg-theme, otherwise infer from CSS
                const headerTheme = header.getAttribute("data-bg-theme");
                if (headerTheme) return headerTheme;
                // Most headers are light-colored, so return "light" to use dark scrollbar
                // Check computed background color to be more accurate
                const headerBg =
                  window.getComputedStyle(header).backgroundColor;
                if (headerBg) {
                  // Parse RGB and check luminance
                  const match = headerBg.match(
                    /rgba?\((\d+),\s*(\d+),\s*(\d+)/,
                  );
                  if (match) {
                    const r = parseInt(match[1]);
                    const g = parseInt(match[2]);
                    const b = parseInt(match[3]);
                    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                    return luminance > 0.5 ? "light" : "dark";
                  }
                }
                return "light"; // Default header to light
              }
            }
          }

          // Find which section is at this screen Y position
          for (let i = 0; i < sections.length; i++) {
            const section = sections[i];
            const rect = section.getBoundingClientRect();
            if (screenY >= rect.top && screenY < rect.bottom) {
              return section.getAttribute("data-bg-theme");
            }
          }
          return null;
        }

        function updateScrollbarTheme() {
          if (sections.length === 0) return;

          const scrollY = window.scrollY;
          const windowHeight = window.innerHeight;

          // Get thumb's screen position (where it visually appears)
          const thumbRect = thumb.getBoundingClientRect();
          const thumbCenterY = thumbRect.top + thumbRect.height / 2;

          // Get theme for thumb based on what section it's visually over on screen
          // Also check header for thumb since it may overlap
          const thumbTheme = getThemeAtScreenY(thumbCenterY, true);
          const currentThumbTheme = thumb.getAttribute("data-theme");
          if (thumbTheme && thumbTheme !== currentThumbTheme) {
            thumb.setAttribute("data-theme", thumbTheme);
          } else if (!thumbTheme && currentThumbTheme) {
            thumb.removeAttribute("data-theme");
          }

          // Up arrow is at top of screen - check header first, then sections
          const upArrowRect = arrowUp.getBoundingClientRect();
          const upArrowCenterY = upArrowRect.top + upArrowRect.height / 2;
          const upArrowTheme = getThemeAtScreenY(upArrowCenterY, true);
          const currentUpTheme = arrowUp.getAttribute("data-theme");
          if (upArrowTheme && upArrowTheme !== currentUpTheme) {
            arrowUp.setAttribute("data-theme", upArrowTheme);
          } else if (!upArrowTheme && currentUpTheme) {
            arrowUp.removeAttribute("data-theme");
          }

          // Down arrow is at bottom of screen - check what section is at bottom of viewport
          const downArrowRect = arrowDown.getBoundingClientRect();
          const downArrowCenterY = downArrowRect.top + downArrowRect.height / 2;
          const downArrowTheme = getThemeAtScreenY(downArrowCenterY, false);
          const currentDownTheme = arrowDown.getAttribute("data-theme");
          if (downArrowTheme && downArrowTheme !== currentDownTheme) {
            arrowDown.setAttribute("data-theme", downArrowTheme);
          } else if (!downArrowTheme && currentDownTheme) {
            arrowDown.removeAttribute("data-theme");
          }
        }

        window.addEventListener("scroll", updateScrollbarTheme);

        // Also update theme when scrollbar updates (for thumb position changes)
        lenis.on("scroll", updateScrollbarTheme);

        // Initial update
        updateScrollbarTheme();
      }

      function initializeAll() {
        initSmoothScrolling();
      }

      // Listen for both Astro page-load and DOM content loaded
      document.addEventListener("astro:page-load", initializeAll);

      // Fallback for initial page load
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeAll);
      } else {
        // DOM is already ready
        initializeAll();
      }
    </script>
  </body>
</html>

<style is:global>
  main {
    padding-top: var(--header-height);
    min-height: 100vh;
    position: relative;
    z-index: 1;
  }

  /* Hide Native Scrollbar */
  html {
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  html::-webkit-scrollbar {
    display: none;
  }

  /* Custom Scrollbar Container - Modern Chrome Style */
  .custom-scrollbar {
    position: fixed;
    top: 0;
    right: 0;
    width: 12px;
    height: 100vh;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    background: transparent;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }

  /* Show on hover */
  .custom-scrollbar:hover,
  .custom-scrollbar.scrolling {
    opacity: 1;
    pointer-events: auto;
  }

  /* Arrow Buttons - Minimal Style */
  .scroll-arrow {
    width: 100%;
    height: 16px;
    background: transparent;
    cursor: default;
    position: relative;
    flex-shrink: 0;
    transition: opacity 0.15s ease;
    border-radius: 0;
    pointer-events: auto;
  }

  .scroll-arrow:hover::after {
    opacity: 0.8;
  }

  .scroll-arrow:active::after {
    opacity: 1;
  }

  /* Arrow Icons */
  .scroll-arrow::after {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-left: 3px solid transparent;
    border-right: 3px solid transparent;
    opacity: 0.5;
    transition: opacity 0.15s ease;
  }

  .scroll-arrow-up::after {
    border-bottom: 4px solid rgba(0, 0, 0, 0.8);
  }

  .scroll-arrow-down::after {
    border-top: 4px solid rgba(0, 0, 0, 0.8);
  }

  /* Track - Transparent */
  .scroll-track {
    flex-grow: 1;
    position: relative;
    width: 100%;
    background: transparent;
    pointer-events: auto;
  }

  /* Thumb - Chrome Modern Style */
  .custom-thumb {
    position: absolute;
    top: 0;
    right: 0;
    width: 8px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: default;
    transition:
      background 0.2s ease,
      width 0.2s ease;
    pointer-events: auto;
  }

  .custom-thumb:hover {
    background: rgba(0, 0, 0, 0.5);
    width: 10px;
  }

  .custom-thumb.dragging {
    background: rgba(0, 0, 0, 0.6);
    width: 10px;
  }

  /* Full-width thumb style - always 10px, no expand on hover */
  .custom-scrollbar[data-thumb-style="full"] .custom-thumb {
    width: 10px;
  }

  .custom-scrollbar[data-thumb-style="full"] .custom-thumb:hover,
  .custom-scrollbar[data-thumb-style="full"] .custom-thumb.dragging {
    width: 10px;
  }

  /* Theme-Aware Scrollbar Styles - Independent per element */
  /* Dark backgrounds - use light thumb */
  .custom-thumb[data-theme="dark"] {
    background: rgba(255, 255, 255, 0.3);
  }

  .custom-thumb[data-theme="dark"]:hover {
    background: rgba(255, 255, 255, 0.5);
    width: 10px;
  }

  .custom-thumb[data-theme="dark"].dragging {
    background: rgba(255, 255, 255, 0.6);
    width: 10px;
  }

  /* Independent arrow theming */
  .scroll-arrow-up[data-theme="dark"]::after {
    border-bottom: 4px solid rgba(255, 255, 255, 0.8);
  }

  .scroll-arrow-down[data-theme="dark"]::after {
    border-top: 4px solid rgba(255, 255, 255, 0.8);
  }

  /* Legacy support: scrollbar container with data-theme */
  .custom-scrollbar[data-theme="dark"] .custom-thumb:not([data-theme]) {
    background: rgba(255, 255, 255, 0.3);
  }

  .custom-scrollbar[data-theme="dark"] .custom-thumb:not([data-theme]):hover {
    background: rgba(255, 255, 255, 0.5);
    width: 10px;
  }

  .custom-scrollbar[data-theme="dark"]
    .custom-thumb:not([data-theme]).dragging {
    background: rgba(255, 255, 255, 0.6);
    width: 10px;
  }

  .custom-scrollbar[data-theme="dark"]
    .scroll-arrow-up:not([data-theme])::after {
    border-bottom: 4px solid rgba(255, 255, 255, 0.8);
  }

  .custom-scrollbar[data-theme="dark"]
    .scroll-arrow-down:not([data-theme])::after {
    border-top: 4px solid rgba(255, 255, 255, 0.8);
  }

  /* Show scrollbar when hovering the page edge */
  body:hover .custom-scrollbar {
    opacity: 1;
    pointer-events: auto;
  }

  /* Global Dark Theme Support - Light scrollbar for dark themed pages */
  html[data-theme="dark"] .custom-thumb {
    background: rgba(255, 255, 255, 0.3);
  }

  html[data-theme="dark"] .custom-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
  }

  html[data-theme="dark"] .custom-thumb.dragging {
    background: rgba(255, 255, 255, 0.6);
  }

  html[data-theme="dark"] .scroll-arrow-up::after {
    border-bottom-color: rgba(255, 255, 255, 0.8);
  }

  html[data-theme="dark"] .scroll-arrow-down::after {
    border-top-color: rgba(255, 255, 255, 0.8);
  }
</style>
