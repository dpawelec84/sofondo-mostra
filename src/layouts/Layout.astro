---
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import "../styles/global.css";
import { ClientRouter } from "astro:transitions";
import { siteConfig } from "../config/site";

interface Props {
  title: string;
}

const { title } = Astro.props;

// Feature flags from config
const { smoothScrolling, customScrollbar, shardsBackground, viewTransitions } = siteConfig.features;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="description"
      content={siteConfig.description}
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    {viewTransitions && <ClientRouter />}
    <!-- Preload fonts to eliminate FOUT -->
    <link
      rel="preload"
      href="/fonts/fraunces-latin.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <link
      rel="preload"
      href="/fonts/outfit-latin.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <style>
      /* Self-hosted fonts */
      @font-face {
        font-family: 'Fraunces';
        font-style: normal;
        font-weight: 400 700;
        font-display: swap;
        src: url('/fonts/fraunces-latin.woff2') format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }
      @font-face {
        font-family: 'Outfit';
        font-style: normal;
        font-weight: 400 700;
        font-display: swap;
        src: url('/fonts/outfit-latin.woff2') format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      }
    </style>
    {siteConfig.logo.src && <link rel="preload" href={siteConfig.logo.src} as="image" />}
  </head>
  <body>
    {/* Interactive Shards Background - conditionally rendered */}
    {shardsBackground && (
      <div class="shards-wrapper" transition:persist="shards">
        <canvas id="shards-canvas" class="shards-bg"></canvas>
      </div>
    )}

    <Header />
    <main>
      <slot />
    </main>
    <Footer />

    {/* Custom Scrollbar Structure - conditionally rendered */}
    {customScrollbar && (
      <div class="custom-scrollbar">
        <div class="scroll-arrow scroll-arrow-up" aria-hidden="true"></div>
        <div class="scroll-track">
          <div class="custom-thumb"></div>
        </div>
        <div class="scroll-arrow scroll-arrow-down" aria-hidden="true">
        </div>
      </div>
    )}

    <script define:vars={{ smoothScrolling, customScrollbar, shardsBackground }}>
      // Global declarations for persisting animation state
      window.__shardsAnimationId = window.__shardsAnimationId || undefined;
      window.__shardsAnimating = window.__shardsAnimating || false;
      window.__shardsData = window.__shardsData || [];
      window.__shardsAnimationTime = window.__shardsAnimationTime || 0;
      window.__shardsMouseX = window.__shardsMouseX || undefined;
      window.__shardsMouseY = window.__shardsMouseY || undefined;
      window.__shardsCurrentMouseX = window.__shardsCurrentMouseX || undefined;
      window.__shardsCurrentMouseY = window.__shardsCurrentMouseY || undefined;
      window.__shardsGlobalTargetPosition = window.__shardsGlobalTargetPosition || "bottom";

      // Store feature flags globally for the initialization script
      window.__featureFlags = {
        smoothScrolling,
        customScrollbar,
        shardsBackground
      };
    </script>

    <script>
      import Lenis from "@studio-freight/lenis";

      function initSmoothScrolling() {
        const flags = (window as any).__featureFlags || {};
        if (!flags.smoothScrolling && !flags.customScrollbar) return;

        // Custom Scrollbar Logic
        const scrollbar = document.querySelector(
          ".custom-scrollbar",
        ) as HTMLElement;
        const track = document.querySelector(".scroll-track") as HTMLElement;
        const thumb = document.querySelector(".custom-thumb") as HTMLElement;
        const arrowUp = document.querySelector(
          ".scroll-arrow-up",
        ) as HTMLElement;
        const arrowDown = document.querySelector(
          ".scroll-arrow-down",
        ) as HTMLElement;

        if (!flags.customScrollbar || !scrollbar || !track || !thumb || !arrowUp || !arrowDown) {
          // If no custom scrollbar but smooth scrolling is enabled, still init Lenis
          if (flags.smoothScrolling) {
            const lenis = new Lenis({
              duration: 1.2,
              easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
              orientation: "vertical",
              gestureOrientation: "vertical",
              smoothWheel: true,
              wheelMultiplier: 1,
              touchMultiplier: 2,
            });

            window.addEventListener("mobile-menu-toggle", ((e: CustomEvent) => {
              const isOpen = e.detail.isOpen;
              if (isOpen) {
                lenis?.stop();
                document.documentElement.style.overflow = "hidden";
                document.body.style.overflow = "hidden";
                document.body.classList.add("mobile-menu-open");
              } else {
                lenis?.start();
                document.documentElement.style.overflow = "";
                document.body.style.overflow = "";
                document.body.classList.remove("mobile-menu-open");
              }
            }) as EventListener);

            function raf(time: number) {
              lenis.raf(time);
              requestAnimationFrame(raf);
            }
            requestAnimationFrame(raf);
          }
          return;
        }

        // Initialize Lenis
        const lenis = new Lenis({
          duration: 1.2,
          easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
          orientation: "vertical",
          gestureOrientation: "vertical",
          smoothWheel: true,
          wheelMultiplier: 1,
          touchMultiplier: 2,
        });

        // Listen for mobile menu toggle events
        window.addEventListener("mobile-menu-toggle", ((e: CustomEvent) => {
          const isOpen = e.detail.isOpen;
          if (isOpen) {
            lenis?.stop();
            document.documentElement.style.overflow = "hidden";
            document.body.style.overflow = "hidden";
            document.body.classList.add("mobile-menu-open");
          } else {
            lenis?.start();
            document.documentElement.style.overflow = "";
            document.body.style.overflow = "";
            document.body.classList.remove("mobile-menu-open");
          }
        }) as EventListener);

        let isDragging = false;
        let startY = 0;
        let startScroll = 0;
        let forcedThumbPosition: number | null = null;
        let targetScrollPosition: number | null = null;
        let lastScrollTime = 0;
        let velocity = 0;
        let isCatchingUp = false;

        // Arrow Physics State
        let arrowDirection = 0;
        let arrowVelocity = 0;
        const ARROW_ACCEL = 1.5;
        const ARROW_MAX_SPEED = 25;
        const ARROW_FRICTION = 0.92;

        function startArrowScroll(direction: "up" | "down") {
          if (isDragging) {
            isDragging = false;
            thumb.classList.remove("dragging");
            document.body.style.userSelect = "";
          }
          forcedThumbPosition = null;
          targetScrollPosition = null;
          arrowDirection = direction === "up" ? -1 : 1;
        }

        function stopArrowScroll() {
          arrowDirection = 0;
        }

        const handleArrowUp = () => startArrowScroll("up");
        const handleArrowDown = () => startArrowScroll("down");

        arrowUp.addEventListener("mousedown", handleArrowUp);
        arrowDown.addEventListener("mousedown", handleArrowDown);

        window.addEventListener("mouseup", stopArrowScroll);
        [arrowUp, arrowDown].forEach((arrow) => {
          arrow.addEventListener("mouseleave", stopArrowScroll);
        });

        // Show scrollbar on scroll
        let scrollTimeout: ReturnType<typeof setTimeout>;
        const handleScroll = () => {
          scrollbar.classList.add("scrolling");
          clearTimeout(scrollTimeout);
          scrollTimeout = setTimeout(() => {
            scrollbar.classList.remove("scrolling");
          }, 1000);
        };
        window.addEventListener("scroll", handleScroll);

        function updateScrollbar() {
          if (!lenis) return;

          const scrollHeight = document.documentElement.scrollHeight;
          const clientHeight = window.innerHeight;

          if (scrollHeight <= clientHeight) {
            scrollbar.style.opacity = "0";
            scrollbar.style.pointerEvents = "none";
            return;
          }
          scrollbar.style.opacity = "1";
          scrollbar.style.pointerEvents = "auto";

          const trackHeight = track.clientHeight;
          const scrollRatio = clientHeight / scrollHeight;
          const thumbHeight = Math.max(40, trackHeight * scrollRatio);
          thumb.style.height = `${thumbHeight}px`;

          const maxScroll = scrollHeight - clientHeight;
          const maxThumbTop = trackHeight - thumbHeight;

          // Update thumb position based on scroll
          if (!isDragging) {
            let scrollPos = lenis.scroll;

            if (isCatchingUp && targetScrollPosition !== null) {
              if (Math.abs(lenis.scroll - targetScrollPosition) < 2) {
                isCatchingUp = false;
              } else {
                scrollPos = targetScrollPosition;
              }
            }

            // Normal scroll - update thumb position to match scroll
            const progress = scrollPos / maxScroll;
            const thumbTop = progress * maxThumbTop;
            thumb.style.transform = `translateY(${thumbTop}px)`;
          }
        }

        // Set up event listeners ONCE
        lenis.on("scroll", updateScrollbar);
        window.addEventListener("resize", updateScrollbar);

        // Initial update
        updateScrollbar();

        // Mouse event handlers for thumb dragging
        const handleThumbMouseDown = (e: MouseEvent) => {
          if (!lenis) return;
          isDragging = true;
          isCatchingUp = false;
          forcedThumbPosition = null;
          targetScrollPosition = null;
          startY = e.clientY;
          startScroll = lenis.scroll;
          thumb.classList.add("dragging");
          document.body.style.userSelect = "none";
        };
        thumb.addEventListener("mousedown", handleThumbMouseDown);

        const handleMouseMove = (e: MouseEvent) => {
          if (!isDragging || !lenis) return;
          e.preventDefault();

          const currentTime = Date.now();
          const deltaY = e.clientY - startY;
          const scrollHeight = document.documentElement.scrollHeight;
          const clientHeight = window.innerHeight;
          const trackHeight = track.clientHeight;
          const thumbHeight = parseFloat(thumb.style.height);
          const maxThumbTop = trackHeight - thumbHeight;
          const maxScroll = scrollHeight - clientHeight;

          const scrollRatio = maxScroll / maxThumbTop;
          const targetScroll = Math.max(
            0,
            Math.min(startScroll + deltaY * scrollRatio, maxScroll),
          );

          // Calculate velocity
          const dt = currentTime - lastScrollTime;
          if (dt > 0) {
            velocity = (targetScroll - lenis.scroll) / dt;
          }
          lastScrollTime = currentTime;

          // Calculate and set thumb position immediately during drag
          const progress = targetScroll / maxScroll;
          const thumbTop = progress * maxThumbTop;

          if (!isNaN(thumbTop)) {
            thumb.style.transform = `translateY(${thumbTop}px)`;
            // Store this position for after release
            forcedThumbPosition = thumbTop;
            targetScrollPosition = targetScroll;
          }

          // Initiate smooth scroll with inertia (immediate: false)
          lenis.scrollTo(targetScroll, { immediate: false });
        };
        window.addEventListener("mousemove", handleMouseMove);

        const handleMouseUp = () => {
          if (isDragging) {
            isDragging = false;
            isCatchingUp = true;
            thumb.classList.remove("dragging");
            document.body.style.userSelect = "";
          }
        };
        window.addEventListener("mouseup", handleMouseUp);

        function raf(time: number) {
          if (!lenis) return;
          try {
            lenis.raf(time);

            // Handle Arrow Physics
            if (arrowDirection !== 0) {
              arrowVelocity += arrowDirection * ARROW_ACCEL;
              if (arrowVelocity > ARROW_MAX_SPEED)
                arrowVelocity = ARROW_MAX_SPEED;
              if (arrowVelocity < -ARROW_MAX_SPEED)
                arrowVelocity = -ARROW_MAX_SPEED;
            } else {
              arrowVelocity *= ARROW_FRICTION;
              if (Math.abs(arrowVelocity) < 0.1) arrowVelocity = 0;
            }

            if (Math.abs(arrowVelocity) > 0.1) {
              lenis.scrollTo(lenis.scroll + arrowVelocity, { immediate: true });
              updateScrollbar();
            }
          } catch (e) {
            // Silently handle scroll errors
          }
          requestAnimationFrame(raf);
        }

        requestAnimationFrame(raf);

        // Context-Aware Scrollbar: Use scroll position to determine theme
        const sections = document.querySelectorAll("[data-bg-theme]");

        function updateScrollbarTheme() {
          if (sections.length === 0) return;

          const scrollY = window.scrollY;
          const windowHeight = window.innerHeight;
          const scrollCenter = scrollY + windowHeight / 2;
          const docHeight = document.documentElement.scrollHeight;
          const atBottom = scrollY + windowHeight >= docHeight - 300;

          // Find which section contains the scroll center point
          let activeSection = null;

          if (atBottom) {
            activeSection = sections[sections.length - 1];
          } else {
            sections.forEach((section) => {
              const rect = section.getBoundingClientRect();
              const sectionTop = scrollY + rect.top;
              const sectionBottom = sectionTop + rect.height;

              if (scrollCenter >= sectionTop && scrollCenter < sectionBottom) {
                activeSection = section;
              }
            });
          }

          if (activeSection) {
            const theme = activeSection.getAttribute("data-bg-theme");
            const currentTheme = scrollbar.getAttribute("data-theme");

            if (theme && theme !== currentTheme) {
              scrollbar.setAttribute("data-theme", theme);
            }
          }
        }

        window.addEventListener("scroll", updateScrollbarTheme);

        // Initial update
        updateScrollbarTheme();
      }

      // Initialize Shards Background

      function initShards(disableFlipping = false) {
        const flags = (window as any).__featureFlags || {};
        if (!flags.shardsBackground) return;

        const canvas = document.getElementById(
          "shards-canvas",
        ) as HTMLCanvasElement;
        if (!canvas) return;

        const wrapper = canvas.parentElement;
        if (!wrapper) return;

        const ctx = canvas.getContext("2d");
        if (!ctx) return;

        // Check if animation is already running (view transition in dev)
        if ((window as any).__shardsAnimating) {
          return;
        }

        // Cancel any existing animation loop to prevent multiple loops running
        if ((window as any).__shardsAnimationId) {
          cancelAnimationFrame((window as any).__shardsAnimationId);
          (window as any).__shardsAnimationId = undefined;
        }

        // Define shard structure
        interface Shard {
          centerX: number;
          bottomY: number;
          topY: number;
          size: number;
          color: string;
          timeOffset: number;
          widthModifier: number;
          targetPosition: "bottom" | "top";
          currentPosition: "bottom" | "top";
          transitionProgress: number;
          delay: number;
          activeDelay: number;
          rotationDirection: 1 | -1;
        }

        // Use existing shards data if available (from previous page), otherwise create new array
        let shards: Shard[] = (window as any).__shardsData || [];

        // Duotone color scheme helper
        function getDuotoneColor(index: number, size: number): string {
          const sizeRatio = (size - 60) / 540;
          const isLightBlue = index % 2 === 0;

          if (isLightBlue) {
            const opacity = 0.06 + sizeRatio * 0.06;
            const lightness = 85 - sizeRatio * 10;
            return `hsla(210, 80%, ${lightness}%, ${opacity})`;
          } else {
            const opacity = 0.08 + sizeRatio * 0.08;
            const lightness = 60 - sizeRatio * 15;
            return `hsla(215, 90%, ${lightness}%, ${opacity})`;
          }
        }

        function generateShards() {
          shards.length = 0;
          // Use canvas buffer dimensions for shard positioning
          const width = canvas.width;
          const height = canvas.height;
          const numShards = 15;

          for (let i = 0; i < numShards; i++) {
            const randomValue = Math.random();
            const size = 60 + Math.pow(randomValue, 0.7) * 540;

            const centerX =
              (width / numShards) * i + Math.random() * (width / numShards);

            // Bottom position (visible part)
            const bottomY = height + 50 + Math.random() * 100;

            // Top position (flipped/rotated destination)
            const topY = -50 - Math.random() * 100;

            shards.push({
              centerX,
              bottomY,
              topY,
              size,
              color: getDuotoneColor(i, size),
              timeOffset: Math.random() * Math.PI * 2,
              widthModifier: 0.5 + Math.random() * 0.5,
              targetPosition: "bottom",
              currentPosition: "bottom",
              transitionProgress: 0,
              delay: Math.random() * 30,
              activeDelay: 0,
              rotationDirection: Math.random() > 0.5 ? 1 : -1,
            });
          }

          // Store globally for persistence across page navigations
          (window as any).__shardsData = shards;
        }

        // Set initial canvas buffer size - oversized to handle viewport expansion
        function initializeCanvasBuffer() {
          const viewport = window.visualViewport || window;
          const currentHeight = (viewport as any).height || window.innerHeight;
          const currentWidth = (viewport as any).width || window.innerWidth;

          // Use screen height as maximum possible viewport (address bar hidden + no home indicator)
          const maxHeight = window.screen.availHeight || (currentHeight * 1.2);

          // Initialize buffer to maximum size to prevent stretching
          canvas.height = maxHeight;
          canvas.width = currentWidth;
        }

        function resizeCanvas() {
          // Detect if mobile device (touch support)
          const isMobile = window.matchMedia("(pointer: coarse)").matches;

          const viewport = window.visualViewport;
          let displayHeight, displayWidth, maxHeight;

          if (viewport) {
            displayHeight = Math.max(viewport.height, window.innerHeight);
            displayWidth = viewport.width;
          } else {
            displayHeight = window.innerHeight;
            displayWidth = window.innerWidth;
          }

          // On mobile: use screen.availHeight to handle address bar transitions
          // On desktop: just use current viewport height
          if (isMobile && window.screen.availHeight && window.screen.availHeight < 3000) {
            maxHeight = Math.max(displayHeight, window.screen.availHeight);
          } else {
            maxHeight = displayHeight;
          }

          // Set wrapper and canvas dimensions
          wrapper.style.height = `${maxHeight}px`;
          wrapper.style.width = `${displayWidth}px`;

          canvas.style.height = `${maxHeight}px`;
          canvas.style.width = `${displayWidth}px`;
        }

        // Initialize canvas buffer once
        initializeCanvasBuffer();

        // Only generate shards if we don't have existing data
        if (shards.length === 0) {
          generateShards();
        }

        // Initial resize to set CSS dimensions
        resizeCanvas();

        // Force additional resize after a short delay to catch viewport stabilization
        setTimeout(resizeCanvas, 100);
        setTimeout(resizeCanvas, 300);
        setTimeout(resizeCanvas, 500);

        // Visual Viewport listeners - BOTH resize AND scroll are critical for mobile!
        if (window.visualViewport) {
          window.visualViewport.addEventListener("resize", resizeCanvas);
          window.visualViewport.addEventListener("scroll", resizeCanvas);
        }

        // Fallback resize listener
        window.addEventListener("resize", resizeCanvas);

        // Also listen to page scroll events as additional safety net
        window.addEventListener("scroll", resizeCanvas, { passive: true });

        // Additional mobile-specific listeners for address bar changes
        let touchActive = false;
        let touchCheckInterval: number | null = null;

        window.addEventListener("touchstart", () => {
          touchActive = true;
          if (!touchCheckInterval) {
            const checkSize = () => {
              if (touchActive) {
                resizeCanvas();
                touchCheckInterval = requestAnimationFrame(checkSize);
              } else {
                touchCheckInterval = null;
              }
            };
            touchCheckInterval = requestAnimationFrame(checkSize);
          }
        }, { passive: true });

        window.addEventListener("touchend", () => {
          touchActive = false;
          if (touchCheckInterval) {
            cancelAnimationFrame(touchCheckInterval);
            touchCheckInterval = null;
          }
          resizeCanvas(); // Final check after touch ends
        }, { passive: true });

        // Mouse tracking - restore from global state if available
        let mouseX = (window as any).__shardsMouseX ?? window.innerWidth / 2;
        let mouseY = (window as any).__shardsMouseY ?? window.innerHeight / 2;
        let currentMouseX = (window as any).__shardsCurrentMouseX ?? mouseX;
        let currentMouseY = (window as any).__shardsCurrentMouseY ?? mouseY;

        const handleMouseMove = (e: MouseEvent) => {
          mouseX = e.clientX;
          mouseY = e.clientY;
          (window as any).__shardsMouseX = mouseX;
          (window as any).__shardsMouseY = mouseY;
        };
        window.addEventListener("mousemove", handleMouseMove);

        // Helper: lerp
        function lerp(start: number, end: number, factor: number) {
          return start + (end - start) * factor;
        }

        let animationTime = (window as any).__shardsAnimationTime ?? 0;

        // Global target state - restore from global state if available
        let globalTargetPosition: "bottom" | "top" = (window as any).__shardsGlobalTargetPosition ?? "bottom";

        // Track scroll position (only if flipping is enabled)
        if (!disableFlipping) {
          window.addEventListener("scroll", () => {
            const currentScrollY = window.scrollY;
            const docHeight = document.documentElement.scrollHeight;
            const windowHeight = window.innerHeight;
            const scrollBottom = currentScrollY + windowHeight;

            // Simple threshold: if close to bottom, go to top. Else bottom.
            const atBottom = scrollBottom >= docHeight - 100;
            globalTargetPosition = atBottom ? "top" : "bottom";
            (window as any).__shardsGlobalTargetPosition = globalTargetPosition;
          });
        }

        // Helper: Rotate point around center
        function rotatePoint(
          x: number,
          y: number,
          cx: number,
          cy: number,
          angle: number,
        ) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          const nx = cos * (x - cx) - sin * (y - cy) + cx;
          const ny = sin * (x - cx) + cos * (y - cy) + cy;
          return { x: nx, y: ny };
        }

        // Animation loop
        function animate() {
          if (!ctx) return;

          animationTime += 0.01;
          (window as any).__shardsAnimationTime = animationTime;

          // Smooth mouse follow
          currentMouseX = lerp(currentMouseX, mouseX, 0.05);
          currentMouseY = lerp(currentMouseY, mouseY, 0.05);
          (window as any).__shardsCurrentMouseX = currentMouseX;
          (window as any).__shardsCurrentMouseY = currentMouseY;

          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw each shard
          shards.forEach((shard, index) => {
            const isSettled =
              (shard.currentPosition === "bottom" &&
                shard.transitionProgress <= 0) ||
              (shard.currentPosition === "top" &&
                shard.transitionProgress >= 1);

            // If settled but not at global target, start new transition
            if (isSettled && shard.targetPosition !== globalTargetPosition) {
              shard.targetPosition = globalTargetPosition;
              shard.activeDelay = shard.delay;
              shard.rotationDirection = Math.random() > 0.5 ? 1 : -1;
            }

            // Handle transition movement
            if (shard.targetPosition === "top") {
              if (shard.activeDelay > 0) {
                shard.activeDelay--;
              } else {
                const speed = 0.015;
                if (shard.transitionProgress < 1) {
                  shard.transitionProgress = Math.min(
                    1,
                    shard.transitionProgress + speed,
                  );
                  if (shard.transitionProgress >= 1)
                    shard.currentPosition = "top";
                }
              }
            } else {
              if (shard.activeDelay > 0) {
                shard.activeDelay--;
              } else {
                const speed = 0.015;
                if (shard.transitionProgress > 0) {
                  shard.transitionProgress = Math.max(
                    0,
                    shard.transitionProgress - speed,
                  );
                  if (shard.transitionProgress <= 0)
                    shard.currentPosition = "bottom";
                }
              }
            }

            // Calculate current state based on progress
            const currentCenterY = lerp(
              shard.bottomY,
              shard.topY,
              shard.transitionProgress,
            );

            const currentRotation = lerp(
              0,
              Math.PI * shard.rotationDirection,
              shard.transitionProgress,
            );

            const spread = shard.size * 0.6 * shard.widthModifier;
            const height = shard.size;

            const v1 = { x: 0, y: -height * 0.6 };
            const v2 = { x: -spread / 2, y: height * 0.4 };
            const v3 = { x: spread / 2, y: height * 0.4 };

            const p1 = rotatePoint(
              v1.x + shard.centerX,
              v1.y + currentCenterY,
              shard.centerX,
              currentCenterY,
              currentRotation,
            );
            const p2 = rotatePoint(
              v2.x + shard.centerX,
              v2.y + currentCenterY,
              shard.centerX,
              currentCenterY,
              currentRotation,
            );
            const p3 = rotatePoint(
              v3.x + shard.centerX,
              v3.y + currentCenterY,
              shard.centerX,
              currentCenterY,
              currentRotation,
            );

            const vertices = [p1, p2, p3];

            ctx.beginPath();

            const parallaxFactor = shard.size / 600;
            const driftX = Math.sin(animationTime + shard.timeOffset) * 5;
            const driftY = Math.cos(animationTime * 0.7 + shard.timeOffset) * 3;

            vertices.forEach((vertex, vertexIndex) => {
              const dx = currentMouseX - vertex.x;
              const dy = currentMouseY - vertex.y;
              const distanceFromMouse = Math.sqrt(dx * dx + dy * dy);
              const influence = Math.max(0, 1 - distanceFromMouse / 500);

              const mouseAttractionX = dx * influence * 0.15 * parallaxFactor;
              const mouseAttractionY = dy * influence * 0.15 * parallaxFactor;

              const independentDriftX = driftX * parallaxFactor;
              const independentDriftY = driftY * parallaxFactor;

              const x = vertex.x + mouseAttractionX + independentDriftX;
              const y = vertex.y + mouseAttractionY + independentDriftY;

              if (vertexIndex === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            });

            ctx.closePath();
            ctx.fillStyle = shard.color;
            ctx.fill();
          });

          // Persist shards state for next navigation
          (window as any).__shardsData = shards;
          (window as any).__shardsAnimationTime = animationTime;
          (window as any).__shardsMouseX = mouseX;
          (window as any).__shardsMouseY = mouseY;
          (window as any).__shardsCurrentMouseX = currentMouseX;
          (window as any).__shardsCurrentMouseY = currentMouseY;
          (window as any).__shardsGlobalTargetPosition = globalTargetPosition;

          (window as any).__shardsAnimationId = requestAnimationFrame(animate);
          (window as any).__shardsAnimating = true;
        }

        animate();
      }

      function initializeAll() {
        initSmoothScrolling();

        // Detect touch device (any touch, not just small screens)
        const isTouchDevice = window.matchMedia("(pointer: coarse)").matches;

        // Initialize shards (will reuse existing shard data if available)
        initShards(isTouchDevice);
      }

      // Listen for both Astro page-load and DOM content loaded
      document.addEventListener("astro:page-load", initializeAll);

      // Fallback for initial page load
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeAll);
      } else {
        // DOM is already ready
        initializeAll();
      }
    </script>
  </body>
</html>

<style is:global>
  /* Interactive Shards Background */
  .shards-wrapper {
    position: fixed;
    top: 0;
    left: 0;
    z-index: -1;
    pointer-events: none;
    overflow: hidden;
  }

  .shards-bg {
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    display: block;
  }

  main {
    padding-top: var(--header-height);
    min-height: 100vh;
    position: relative;
    z-index: 1;
  }

  /* Hide Native Scrollbar */
  html {
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  html::-webkit-scrollbar {
    display: none;
  }

  /* Custom Scrollbar Container - Modern Chrome Style */
  .custom-scrollbar {
    position: fixed;
    top: 0;
    right: 0;
    width: 12px;
    height: 100vh;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    background: transparent;
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }

  /* Show on hover */
  .custom-scrollbar:hover,
  .custom-scrollbar.scrolling {
    opacity: 1;
    pointer-events: auto;
  }

  /* Arrow Buttons - Minimal Style */
  .scroll-arrow {
    width: 100%;
    height: 16px;
    background: transparent;
    cursor: default;
    position: relative;
    flex-shrink: 0;
    transition: opacity 0.15s ease;
    border-radius: 0;
    pointer-events: auto;
  }

  .scroll-arrow:hover::after {
    opacity: 0.8;
  }

  .scroll-arrow:active::after {
    opacity: 1;
  }

  /* Arrow Icons */
  .scroll-arrow::after {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border-left: 3px solid transparent;
    border-right: 3px solid transparent;
    opacity: 0.5;
    transition: opacity 0.15s ease;
  }

  .scroll-arrow-up::after {
    border-bottom: 4px solid rgba(0, 0, 0, 0.8);
  }

  .scroll-arrow-down::after {
    border-top: 4px solid rgba(0, 0, 0, 0.8);
  }

  /* Track - Transparent */
  .scroll-track {
    flex-grow: 1;
    position: relative;
    width: 100%;
    background: transparent;
    pointer-events: auto;
  }

  /* Thumb - Chrome Modern Style */
  .custom-thumb {
    position: absolute;
    top: 0;
    right: 0;
    width: 8px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 4px;
    cursor: default;
    transition:
      background 0.2s ease,
      width 0.2s ease;
    pointer-events: auto;
  }

  .custom-thumb:hover {
    background: rgba(0, 0, 0, 0.5);
    width: 10px;
  }

  .custom-thumb.dragging {
    background: rgba(0, 0, 0, 0.6);
    width: 10px;
  }

  /* Theme-Aware Scrollbar Styles */
  /* Dark backgrounds - use light thumb */
  .custom-scrollbar[data-theme="dark"] .custom-thumb {
    background: rgba(255, 255, 255, 0.3);
  }

  .custom-scrollbar[data-theme="dark"] .custom-thumb:hover {
    background: rgba(255, 255, 255, 0.5);
    width: 10px;
  }

  .custom-scrollbar[data-theme="dark"] .custom-thumb.dragging {
    background: rgba(255, 255, 255, 0.6);
    width: 10px;
  }

  .custom-scrollbar[data-theme="dark"] .scroll-arrow-up::after {
    border-bottom: 4px solid rgba(255, 255, 255, 0.8);
  }

  .custom-scrollbar[data-theme="dark"] .scroll-arrow-down::after {
    border-top: 4px solid rgba(255, 255, 255, 0.8);
  }

  /* Show scrollbar when hovering the page edge */
  body:hover .custom-scrollbar {
    opacity: 1;
    pointer-events: auto;
  }
</style>
